import javafx.scene.Group;
import javafx.scene.Parent;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;

import java.util.Random;
import java.util.concurrent.ArrayBlockingQueue;


/**
 * The Grid Generator class, which will generate boards which contains
 * a grid with tiles (visual tiles)
 * and a group of vehicles that can be moved. board states generated will be stored in a queue
 * to allow for better performance. these boards will be generated on seperate threads while the gui
 * is still running so that levels can be created while the game is being played. these ThreadState
 * boards will hold the only information needed for gameplay, the grid the vehicles and the number of moves estimated for challange mode.
 */
public class GridGenerator {
    //the number of successful boards consecutively completed by the user
    //reloading a new level will reset the streak
    private int streakCounter = 0;
    //this will be the grid representing the state (passed into vehicles)
    private Grid grid = new Grid();
    //this will be the main game scene
    private Pane pane = new Pane();
    //this will be the toggaleable menu, it is stored here so it can be added/removed from the game scene
    private VBox menu = new VBox(30);
    //this will be the group of vehicles displayed on the front end
    private Group vehicles = new Group();
    //this label is set to a field so it can constantly be updated, it will be used
    //for counting the number of moves performed by the user
    private Label counter = new Label("Move count - " + grid.getNumberOfMoves());
    //this label is set to a field so it can be constatntly accessed and updated with a function call
    //the streak label will be the display showing the user his current win streak
    private Label streak = new Label("Current Streak - " + streakCounter);
    //this label will be used to display to the user the number of estimated moves needed to complete the board
    //this will be set based on the solution from board solution (number of parent states)
    private Label EstimatedMoves = new Label();
    //this field will be the background grid display for vehicles to be placed on
    private GridPane gridPane = new GridPane();
    //this is the backdrop for when the menu is open
    //creates a translucent black background
    private VBox menubackground = new VBox();
    //this will be the button used to switch scenes for the game, this will need to be a field as it needs
    //to be accessed by the main program state to toggle.
    private Button menuBoard = new Button("Main Menu");

    //these three queues will be used to hold the boards that are being generated by the threads
    //a bounded queue is used because it allows for concurrency works with the thread, it will not accept
    //elements if the queue is full. this will be important to lower cpu usage requirement as we don't want to generate
    //over the threshold and only generate on demand afterwards, since the generation is an expensive proccess, and we
    //can generate on demand after it is full.
    //this will be volatile to make sure it is not cached to thread locally which can cause huge concurrency issues,
    //such as the inconsistency when access through multiple threads.
    //the queue for the easy grids generated (this will be generated on one thread so a list of easy boards can be easily
    //loaded into game
    private volatile ArrayBlockingQueue<ThreadState> easyGrids = new ArrayBlockingQueue<>(15);
    //the queue for the medium grids generated (also generated on a seperate thread), this allows for medium boards to be generated
    //concurrently
    private volatile ArrayBlockingQueue<ThreadState> mediumGrids = new ArrayBlockingQueue<>(10);
    //the final queue for the hard grids generation on a seperate thread, allows for hard boards to be generated concurrently
    //this will mean 3 different levels are ccncurreently generated while(true) (infinitely) until capacity is full, it will sleep
    //when capacity is full. this allows for instant loading of new levels without UI stuttering, as the UI thread
    //will not be used for calculations
    private volatile ArrayBlockingQueue<ThreadState> hardGrids = new ArrayBlockingQueue<>(5);

    //this is the flag to see if challange mode is on
    private boolean challangeMode = false;

    /**
     * Generates a grid with a board of tiles, and a group of vehicles. This method
     * will guarantee to return a Parent which will be used as a root for the scene it is provided
     * to.
     *
     * @return the root used for the scene
     */
    public Parent generateGrid() {
        //this will be the background color for when the menu is loaded, it is also given an opacity so the game can
        //still be seen while this background is around
        menubackground.setStyle("-fx-background-color: rgba(0, 0, 0,0.85); -fx-background-radius: 10;opacity: 0.85;");
        //setting the height for the background to be the height being used for the scene without covering dashboard
        menubackground.setMinHeight(GridVariables.GRID_HEIGHT + 3);
        //setting the width of the background to be the width used for the scene
        menubackground.setMinWidth(GridVariables.GRID_WIDTH);
        //the background color for the main game is black incase user resizes, black is a nicer background, easier on the eyes
        pane.setStyle("-fx-background-color: black");
        //set the size of the parent to the resolution in the global grid variables.
        pane.setPrefSize(GridVariables.GRID_WIDTH, GridVariables.GRID_HEIGHT);
        //this will be setting up for the toggaleable menu
        //the menu id is the main menu
        menu.setId("Main Menu");
        //relocating the menu to the relative center of the screen
        menu.relocate(GridVariables.GRID_WIDTH / 2 - 50, GridVariables.GRID_HEIGHT / 3 - 50);
        //this will all be buttons for the menu
        //---------------------------------------------------------------------------------------------------------
        //the easy button will be used for reloading an easy level, however upon reloading level it will reset the streak
        Button easy = new Button("Easy Level");
        //we are adding the style
        easy.getStylesheets().add("Buttons.css");
        //when the burron is pressed
        easy.setOnAction(e -> {
            //we want to set the difficulty of all boards loaded and current board to be easy
            grid.setDifficulty(Difficulty.EASY);
            //we will try to reload the board (this has to be put in try catch due to sleep in the method
            reGenerate();
            //we still want to keep the menu up incase user is not satisfied with the level loaded can
            //this can be turned off by toggling the menu itself with the key
            //still keep reloading
            //push the background to the front of display
            menubackground.toFront();
            //now we want to push the menu itself ontop of the background
            menu.toFront();
            //reset the streak
            streakCounter = 0;
            //update the dashboard at the bottom
            updateCounter();
            updateStreakGUI();
        });

        //this will be the button used for generating intermediate levels for the user
        Button medium = new Button("Medium Level");
        //want to add the button css to stylt the button better
        medium.getStylesheets().add("Buttons.css");
        //when the medium button is pressed we want to load a medium level
        //reset counters and keep menu is open, won't close menu should be toggled if want to be closed
        //to avoid annoyance of having to constantly re-open the menu
        medium.setOnAction(e -> {
            //if there are no medium grids we dont want to load a new level for the user, it will cause ui stutter
            //easy grids are generated so quickly that this will never be an issue for easy grids, but for medium ones
            //to avoid ui stutter
            if (mediumGrids.size() == 0)
                return;
            //we want to set the current ongoing difficulty of boards to be medium
            grid.setDifficulty(Difficulty.MEDIUM);
            //now we want to attempt to load the board from the queue using regenerate
            reGenerate();

            //we still want to keep the menu up so the user doesnt have issues with needing to retoggle
            menubackground.toFront();
            //push the menu onto the background
            menu.toFront();
            //reset the streak since button was used
            streakCounter = 0;
            //now we want to update the dashboard by resetting counters
            updateCounter();
            updateStreakGUI();
        });
        //this will be the hard difficulty button used to change the game difficulty, and reload a hard board onto the
        //ui for the user
        Button hard = new Button("Hard Level");
        //adding the style for the button for nicer ui design
        hard.getStylesheets().add("Buttons.css");
        //when the button is pressed we want to reset counters, update ui and load a new grid onto the board
        hard.setOnAction(e -> {
            //we want to set the ongoing difficulty as hard
            grid.setDifficulty(Difficulty.HARD);
            //this will load a hard board from the grid for the user if it can
            reGenerate();
            //push the menu background to cover the display
            menubackground.toFront();
            //push the menu ontop of the background
            menu.toFront();
            //reset the streak since button was used to reload
            streakCounter = 0;
            //update the dashboard by resetting the counter
            updateCounter();
            updateStreakGUI();
        });
        //this button will be used as a toggle for the sounds in the game
        Button sound = new Button("Toggle sound");
        //set the style for the button from the css file
        sound.getStylesheets().add("Buttons.css");
        //the action for the sound  toggle will be to switch the flag
        sound.setOnAction(e -> {
            //if the sound for the state is set on
            if (grid.isSound()) {
                //we want to turn off the sound
                grid.setSound(false);
                //now we want to add a red border around to signify that the sound is off
                sound.setStyle("-fx-border-color: red; -fx-border-width: 2");
            } else {
                //otherwise the alternative is the sound is off, and we we want to set it back on
                grid.setSound(true);
                //we want to remove the red border from the button
                sound.setStyle("-fx-borer-color: none;");
            }
        });
        //this will be the button used for accessing the menu scene again, however it's action is set on the
        //amin stage
        menuBoard.getStylesheets().add("Buttons.css");
        //the exit button which will be used to exit the program
        Button exit = new Button("Exit");
        //adding the css style to the button
        exit.getStylesheets().add("Buttons.css");
        //when the exit button is pressed
        exit.setOnAction(e -> {
            //exit the program
            System.exit(0);
        });
        //this will be the bottom dashboard underneath the game showing the relevant counters
        VBox dashBoard = new VBox(30);
        //we want to add all the extra dashboard buttons
        dashBoard.getChildren().addAll(sound, menuBoard, exit);
        //now we want to add all of our buttons to the menu
        menu.getChildren().addAll(easy, medium, hard, dashBoard);
        //initalising the rows for this grid (adds a slot at each row index)
        for (int i = 0; i < GridVariables.BOARD_SIZE; i++) {
            //initalises rows for the grid pane
            RowConstraints row = new RowConstraints();
            //this lets the nodes fill the grid tile
            row.setFillHeight(true);
            gridPane.getRowConstraints().add(row);
        }
        //initalising the columns for this grid (adds a slot at each col index)
        for (int i = 0; i < GridVariables.BOARD_SIZE; i++) {
            //initalises the columns for the grid pane
            ColumnConstraints col = new ColumnConstraints();
            //this lets the nodes fill the grid tile
            col.setFillWidth(true);
            gridPane.getColumnConstraints().add(col);
        }

        //filling our grid with tiles for the game
        for (int i = 0; i < GridVariables.BOARD_SIZE; i++) {
            for (int j = 0; j < GridVariables.BOARD_SIZE; j++) {
                //tiles are represented by a rectangle that is white with black border
                //the -1.15 is so the rectangle fits better with the vehicles
                Rectangle tile = new Rectangle(GridVariables.TILE_SIZE_WIDTH - 1.15, GridVariables.TILE_SIZE_HEIGHT - 1.15);
                if (i == GridVariables.BOARD_SIZE - 1 && j == grid.getGoalRow()) {
                    //this sets the goal tile filled green so it stands out better
                    //the stroke is a black border around the grid
                    tile.setStroke(Color.BLACK);
                    tile.setFill(Color.PALEGREEN);
                    //the goal tile will have NO rounding
                    tile.setArcHeight(15);
                    tile.setArcWidth(15);
                }
                //otherwise every other tile will be filled white with a black border
                else {
                    //fill the rectangle with grey, has a nicer contrast to the vehicles
                    //add a black border for the rectangle
                    tile.setFill(Color.GREY);
                    tile.setStroke(Color.BLACK);
                    //this will slightly round the rectangles for smoother shapes but not as round as the vehicles
                    //the regular tiles arent as rounded as goal tile on purpose
                    tile.setArcHeight(15);
                    tile.setArcWidth(15);
                }
                //add the tile to the grid pane
                gridPane.add(tile, i, j);
            }
        }
        //this will be a horizontal box for the bottom
        HBox dash = new HBox(GridVariables.GRID_WIDTH / 40);
        //visualising the counter for the user
        counter.setTextFill(Color.GREY);
        //we want to set the font for the counter to be consistent with all other fonts
        //based on font grid height size
        counter.setFont(new Font("Impact", GridVariables.GRID_HEIGHT / 18));

        //we want another counter for the current streak the user is on
        streak.setTextFill(Color.GREY);
        //we want to set the font for the counter to be consistent with all other fonts
        //based on font grid height size
        streak.setFont(new Font("Impact", GridVariables.GRID_HEIGHT / 18));

        //the final part of the dashboard is an estimated turns required for solution which is found from the solver
        EstimatedMoves.setTextFill(Color.GREY);
        //we want to set the font to keep consistent and base it foff the height of the grid
        EstimatedMoves.setFont(new Font("Impact", GridVariables.GRID_HEIGHT / 18));

        //now we want to add to our evenly spaced dash the counters
        dash.getChildren().addAll(counter, streak, EstimatedMoves);
        //relocate it just below the game board
        dash.relocate(0, GridVariables.GRID_HEIGHT + 5);
        //the only things we want initally loaded into the game state we are returning
        //is the background for the game, and the dashboard
        pane.getChildren().addAll(gridPane, dash);
        //return the final board containing the grid and the group of vehicles
        return pane;
    }

    /**
     * This method will be used to toggle the menu. toggling the menu will place a opaque black background
     * to take focus off the game board from the menu, and placed a menu on top of the view. This will be
     * done by placing the menu pair on top of the view and bringing it to the front, so the other elements are still
     * there, but the menu is the focus. To disable the menu it will remove the pair from the game view.
     * <p>
     * This method will guarantee to switch the view and toggle the menu.
     */
    public void toggleMenu() {
        //if the menu is there we want to toggle it off
        if (pane.getChildren().contains(menu)) {
            //remove the menu from the pane
            pane.getChildren().remove(menu);
            //remove the background from the pane
            pane.getChildren().remove(menubackground);
        }
        //if the menu is not on the board
        else if (!pane.getChildren().contains(menu)) {
            //we want to add the background
            pane.getChildren().add(menubackground);
            //bringing the background to front to make it focus
            menubackground.toFront();
            //adding the menu to the pane
            pane.getChildren().add(menu);
            //this will put the menu as the focus with the background
            menu.toFront();
        }
    }

    /**
     * This method will be used to reset the game state. it will be used to clear all vehicles
     * in the group, removing everything from the board. it will also reset the victory flag as
     * new state. and will clear all occupied spaces in the 2d matrix grid. This method guarantees
     * to wipe the variables passed. provided it receives a non null grid, and a non null group of vehicles.
     *
     * @param grid     the 2d matrix which represents the current game state
     * @param vehicles the list of vehicles which are representing the front end
     */
    public void clearGrid(Grid grid, Group vehicles) {
        //no longer victory, change the flag to false
        grid.setVictory(false);
        //this function will wipe every object from the grid
        grid.resetNewGrid();
        //this will clear the list of vehicles from the current board
        vehicles.getChildren().clear();
    }

    /**
     * Due to 3 difficulties being available for the user, there needs to be a
     * This method will be responsible for generating easy grids. This will be done
     * by placing the goal car in a random column on the goal row. A inital random number of vehicles
     * subject to change in the BFS class. the BFS class will then attempt to generate a new state
     * to store in a queue that can be loaded. This method will always guarantee to add a
     * non null easy state to the easy board state queue.
     */
    /*
     * when generating a easy grid we want to
     * 1. randomly place vehicles in random size and orientation on the board
     * 2. make sure placement is so that no block will overlap on placement
     * 3. perform BFS to try and solve the board state
     * 4. count number of moves from BFS
     * 5. if the BFS returns a solution within the easy threshold, we use that board
     * 6. otherwise we will keep generating board repeating step 3-7
     */
    public void generateEasyGrid() {
        //we dont want to keep generating over the queue size capacity this will sue ALOT more cpu
        if (easyGrids.remainingCapacity() == 0)
            return;
        //initialise a new grid for a state
        Grid tmp = new Grid();
        //initalise a list of vehicles assosciated with that state
        Group tmpVehicles = new Group();
        //initialise the number of moves to be 0 (ONLY FOR STANDARD MODE)
        tmp.setNumberOfMoves(0);
        //set the difficulty of search to be easy
        Difficulty difficulty = Difficulty.EASY;
        //set the difficulty of the grid to be Easy
        tmp.setDifficulty(difficulty);
        //create a random number generator for creating random values
        Random generator = new Random();
        //the goal car will always be horizontal with size 2 in the goal row
        Vehicle goalCar = new Vehicle(true, 2);
        //create the front end state of the goal vehicle, but for the row place it always between row 0-2
        GridVehicle goalVehicle = new GridVehicle(true, goalCar, 2, generator.nextInt(3), tmp);
        //initialising search
        boolean result = false;
        //randomise the number of vehicles to add between 4-20
        int numberOfVehicles = generator.nextInt(17) + 4;
        //create the search class
        BFS search = new BFS();
        //keep creating boards till one of them has a solution.
        while (!result) {
            //to avoid HEAVY cpu loads want to sleep for 100ms
            threadSleep(100);
            //will check the board can be solved and will continously create boards till one of them has a solution
            result = search.createState(difficulty, numberOfVehicles, tmp, tmpVehicles, goalVehicle);
        }
        //a thread state is a state created on a thread, it will contain the grid for the board state
        //and the vehicle list for that board state
        ThreadState state = new ThreadState(tmp);
        //set the estimated moves required to complete the state as the size of the path from the search
        state.setEstimatedMoves(search.getNumberOfMovesEstimate());
        //add to the list of easy states the created state
        try {
            easyGrids.put(state);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }

    /**
     * Due to 3 difficulties being available for the user, there needs to be a
     * This method will be responsible for generating intermediate grids. This will be done
     * by placing the goal car in a random column on the goal row. A inital random number of vehicles
     * subject to change in the BFS class. the BFS class will then attempt to generate a new state
     * to store in a queue that can be loaded. This method will always guarantee to add a
     * non null easy state to the medium board states queue.
     */
    /*
     * when generating a easy grid we want to
     * 1. randomly place vehicles in random size and orientation on the board
     * 2. make sure placement is so that no block will overlap on placement
     * 3. perform BFS to try and solve the board state
     * 4. count number of moves from BFS
     * 5. if the BFS returns a solution within the medium threshold, we use that board
     * 6. otherwise we will keep generating board repeating step 3-7
     */
    public void generateMediumGrid() {
        //we dont want to keep generating over the queue size capacity this will sue ALOT more cpu
        if (mediumGrids.remainingCapacity() == 0)
            return;
        //initialise a new grid for a state
        Grid tmp = new Grid();
        //ccreate an empty list of vehicles to store
        Group tmpVehicles = new Group();
        //set the number of moves for the current state to be 0
        tmp.setNumberOfMoves(0);
        //set the concurrent difficulty to be medium
        Difficulty difficulty = Difficulty.MEDIUM;
        //set the grid difficulty aswell to be medium
        tmp.setDifficulty(difficulty);
        //creating a random generator for random boards
        Random generator = new Random();
        //the goal car will always be horizontal with the same size
        Vehicle goalCar = new Vehicle(true, 2);
        //creating the goal vehicle in goal row within columns 0-2
        GridVehicle goalVehicle = new GridVehicle(true, goalCar, 2, generator.nextInt(3), tmp);
        //initialising the current state of the game to be false
        boolean result = false;
        //randomise the number of vehicles to add between 4-20
        int numberOfVehicles = generator.nextInt(17) + 4;
        //create a instance of the search class
        BFS search = new BFS();
        //perform the search till a state has been created
        while (!result) {
            //to avoid HEAVY cpu loads want to sleep for 100ms
            threadSleep(100);
            //repeats the search till there is a solveable board which can be added to the list
            result = search.createState(difficulty, numberOfVehicles, tmp, tmpVehicles, goalVehicle);
        }
        //creates a new state from the thread to add to the list
        ThreadState state = new ThreadState(tmp);
        //set the number of estimated moves for the state to be the size of the path from the search
        state.setEstimatedMoves(search.getNumberOfMovesEstimate());
        //add the state to the list of medium states
        try {
            mediumGrids.put(state);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }

    /**
     * Due to 3 difficulties being available for the user, there needs to be a
     * This method will be responsible for generating intermediate grids. This will be done
     * by placing the goal car in a random column on the goal row. A inital random number of vehicles
     * subject to change in the BFS class. the BFS class will then attempt to generate a new state
     * to store in a queue that can be loaded. This method will always guarantee to add a
     * non null easy state to the medium board states queue.
     */
    /*
     * when generating a easy grid we want to
     * 1. randomly place vehicles in random size and orientation on the board
     * 2. make sure placement is so that no block will overlap on placement
     * 3. perform BFS to try and solve the board state
     * 4. count number of moves from BFS
     * 5. if the BFS returns a solution within the HARD threshold, we use that board
     * 6. otherwise we will keep generating board repeating step 3-7
     */
    public void generateHardGrid() {
        //we dont want to keep generating over the queue size capacity this will sue ALOT more cpu
        if (hardGrids.remainingCapacity() == 0)
            return;
        //create an empty grid to represent an empty state
        Grid tmp = new Grid();
        //create the list of vehicles to be added to the state
        Group tmpVehicles = new Group();
        //set the initial number of moves to be 0
        tmp.setNumberOfMoves(0);
        //initialise the difficult of the state to be Hard
        Difficulty difficulty = Difficulty.HARD;
        //setr the grid difficulty to hard
        tmp.setDifficulty(difficulty);
        //create a random generator
        Random generator = new Random();
        //since the goal car is always going to be horizontal of size 2
        Vehicle goalCar = new Vehicle(true, 2);
        //create the goal vehicle to be added to the state between column 0 and 2 in the goal row
        GridVehicle goalVehicle = new GridVehicle(true, goalCar, 2, generator.nextInt(3), tmp);
        //initalise the search
        boolean result = false;
        //create a random number of vehicles between 4-20
        int numberOfVehicles = generator.nextInt(17) + 4;
        //create the search class
        BFS search = new BFS();
        //perform search which will generate board states until 1 of them has a solution
        while (!result) {
            //to avoid HEAVY cpu loads want to sleep for 100ms
            threadSleep(100);
            //perform a search creating a new state till it finds a solvable one
            result = search.createState(difficulty, numberOfVehicles, tmp, tmpVehicles, goalVehicle);
        }
        //creates a new state from the thread to add to the list
        ThreadState state = new ThreadState(tmp);
        //set the number of estimated moves for the state to be the size of the path from the search
        state.setEstimatedMoves(search.getNumberOfMovesEstimate());
        //since the other threads will only generate till full and then divert to the hard thread
        //to avoid attemtping to add over the capacity of the hard grids
        //we wont add if there is no space
        if (hardGrids.remainingCapacity() > 0)
        //add the state to the harder list of grids
        {
            try {
                hardGrids.put(state);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * This method will be the method used to retrieve the next board of current difficulty from the list
     * it will check what the concurrent difficulty or chosen difficult is at, and then will attempt to take
     * the first state from the arrayblocking queue, if no elements exists it will create one, and a board will be loaded
     * and displayed for the user. it will be used to regenerate a board of chosen/concurrent difficulty.
     * <p>
     * This method guarantees to always load a board state for user to play based on the difficulty that was selected or pre-exisiting.
     */
    public void reGenerate() {
        //this will update the status of menu with a green border or no border if no levels
        //green border = levels in queue, no border = no level
        //note this is suseptible to delays, so if a user spam clicks generating levels it won't have time to update
        updateMenuStatus();
        //if the difficulty was not set for some reason or the current concurrent difficulty is easy
        if (null == grid.getDifficulty() || grid.getDifficulty().equals(Difficulty.EASY)) {
            //first check if queue of states is empty
            if (easyGrids.isEmpty()) {
                //if the queue of states is even
                //we want to generate a board manually note this will be taxing on the ui thread will cause slight
                //freeze
                generateEasyGrid();
            }
            //now we want to attempt to take from the easy grid queue with try/catch exception
            //take is similair to put where it will lock on null to allow work with concurrency
            ThreadState pop = null;
            try {
                pop = easyGrids.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //if for some unknown reason it manages to throw an exception return, user can just load
            //another level dont wan't any null pointer exceptions
            if (null == pop)
                return;
            //now we want to make sure we clear the grid state
            clearGrid(grid, vehicles);
            clearGrid(grid, vehicles);
            //we want to set the grid now to the popped state's grid
            grid = pop.retGrid();
            //since we are on the easy case set the grid difficulty to easy
            grid.setDifficulty(Difficulty.EASY);
            //we want to set the vehicles to be the popped states vehicle list
            vehicles = pop.getVehicles();
            //now we want to add the vehicle list to the pane which will finish the front end placement
            pane.getChildren().add(vehicles);
            //now we want to set the challange mode to be the current state of challange mode
            grid.setChallangeMode(challangeMode);
            //now we want to set the estimated moves needed to finish the grid to be the popped of states
            //stored from the search
            EstimatedMoves.setText("Estimated moves: " + pop.getEstimatedMoves());
            //if challange mode is on we want to set the number of moves from the grid
            //to be the number of estimated moves, since challange mode has turn RESTRICTIONS
            //with limited number of moves
            if (grid.isChallangeMode()) {
                grid.setNumberOfMoves(pop.getEstimatedMoves());
            }
            return;
        }
        //case if the grid difficulty is set to medium
        if (grid.getDifficulty().equals(Difficulty.MEDIUM)) {
            //if the concurrent blocking queue of medium states is empty
            //we want to load a board for the user, however this will cause ui lag in this case
            //as it will generate the new board on the main thread.
            if (mediumGrids.isEmpty()) {
                generateMediumGrid();
            }
            //now we want to take a state of medium difficulty from the queue of states
            ThreadState pop = null;
            try {
                pop = mediumGrids.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //if from some miraculous reason the state taken is null, we just want to
            //return, user can retry to load new board
            if (null == pop)
                return;
            //making sure we clear the grid to avoid major board invisible obtacle issues
            clearGrid(grid, vehicles);
            clearGrid(grid, vehicles);
            //now set the game grid to be the state grid popped from the queue
            grid = pop.retGrid();
            //now we want to set the game mode to be challange mode if the boolean is turned on or turn it off
            grid.setChallangeMode(challangeMode);
            //set the current difficulty of the board to be intermediate
            grid.setDifficulty(Difficulty.MEDIUM);
            //we want to set the list of vehicles to be associated with that board to be the
            //list of vehicles in threadstate class
            vehicles = pop.getVehicles();
            //now we want to load those vehicles onto the main board
            pane.getChildren().add(vehicles);
            //we want to set the number of estimated moves to be size of path during search for that state
            EstimatedMoves.setText("Estimated moves: " + pop.getEstimatedMoves());
            //if challange mode is on we want to set the number of available moves to be that
            //size of path from the search
            if (grid.isChallangeMode()) {
                grid.setNumberOfMoves(pop.getEstimatedMoves());
            }
            return;
        }
        //final case will be if the difficulty is set to HARD
        if (grid.getDifficulty().equals(Difficulty.HARD)) {
            //if the list of hard grids is empty (reccommended not to load from this list unless
            //there are boards in the queue (aka dont spam click the button please)
            if (hardGrids.isEmpty()) {
                //we want to generate a hard grid if the concurrent queue is empty
                //this will be really taxing on the program as it will be done on the main thread and cause
                //the ui to freeze till loaded.
                generateHardGrid();
            }
            //now we want to try to take a state from the queue of hard vehicles
            ThreadState pop = null;
            try {
                pop = hardGrids.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //if for some forbidden reason a state is not able to be popped up, we want to return
            //rather than assigning null values ^_^, this will require user to press button to play again
            if (null == pop)
                return;
            //now we want to clear the grid so we don't create invisible obstacles
            clearGrid(grid, vehicles);
            clearGrid(grid, vehicles);
            //we want to set the grid for the main game to be the grid state popped from the queue
            grid = pop.retGrid();
            //we want to toggle challange mode incase it has changed
            grid.setChallangeMode(challangeMode);
            //set the board difficulty to hard
            grid.setDifficulty(Difficulty.HARD);
            //now we want to set our front end vehicles to be the list of vehicles assosciated with that state
            vehicles = pop.getVehicles();
            //now we want to add the vehicles to the front end
            pane.getChildren().add(vehicles);
            //if challange mode is on we want to set the number of moves to be the estimate, since
            //counter will decrement
            if (grid.isChallangeMode()) {
                grid.setNumberOfMoves(pop.getEstimatedMoves());
            }
            //set the estimated number of moves for the board to be the size of path from the search
            EstimatedMoves.setText("Estimated moves: " + pop.getEstimatedMoves());
        }

    }

    /**
     * This method will be used to retrieve the grid for the current game mode, this will be used mainly to access
     * methods from within the main scene. This method guarantees to return the grid representing the state of the board
     *
     * @return the grid representing the current game state
     */
    public Grid getGrid() {
        return grid;
    }

    /**
     * This method will be used for updating the gui for the dashboard on the counter. This method will check if
     * challange mode is on and change the text associated accordingly.
     * This method will guarantee to update the counter on the dashboard
     */
    public void updateCounter() {
        //if challange mode is on, we want to put the text to display number of moves remaining
        if (challangeMode)
            counter.setText("Moves remaining: " + grid.getNumberOfMoves());
            //otherwise we want to display how many moves the user has performed
        else
            counter.setText("Move count: " + grid.getNumberOfMoves());
    }

    /**
     * This method will be used for updating the gui for the dashboard with the streak. This method will
     * guarantee to update the current displaying streak
     */
    public void updateStreakGUI() {
        //set the streak text to be the current number of consecutive levels completed without reloading
        streak.setText("Current Streak: " + streakCounter);
    }

    /**
     * This method will be used to update the counter when the user successfully completes a level.
     * once the user completes a level. This method guarantees to always increase the streak counter by one
     */
    public void updateStreak() {
        streakCounter++;
    }

    /**
     * This method will be used when a user is being naughty and wants to load a new level and not complete the current one
     * once a user does the following, it will reset the streak counter to 0. This method will always guarantee to
     * set the streak counter to 0
     */
    public void resetStreak() {
        streakCounter = 0;
    }

    /**
     * This method will be used to retrieve the main menu button on the menu, this is required as this button will
     * change the scene, needed to be performed in the main class with the stage
     *
     * @return the main menu button
     */
    public Button getMenuBoard() {
        return menuBoard;
    }

    /**
     * This method will be used to check if the menu is turned on. This method guarantees
     * to return true if the menu is currently being displayed, or false if otherwise
     *
     * @return true if the menu is turned on, falsde if otherwise
     */
    public boolean menuOn() {
        return pane.getChildren().contains(menu);
    }

    /**
     * This method will be used to retrieve the ArrayBlockingQueue for loading further boards of easy difficulty.
     * This method will guarantee to return the list of easy states concurrently generated
     *
     * @return the list of easy states concurrently generated
     */
    public ArrayBlockingQueue<ThreadState> getEasyGrids() {
        return easyGrids;
    }

    /**
     * This method will be used to retrieve the ArrayBlockingQueue for loading further boards at difficulty intermediate.
     * This method will guarantee to return the list of intermediate states concurrently generated
     *
     * @return the list of intermediate states concurrently generated
     */
    public ArrayBlockingQueue<ThreadState> getMediumGrids() {
        return mediumGrids;
    }

    /**
     * This method will be used to retrieve the ArrayBlockingQueue for loading further boards at hard difficulty.
     * This method will guarantee to return the list of hard states concurrently generated
     *
     * @return the list of hard states concurrently generated
     */
    public ArrayBlockingQueue<ThreadState> getHardGrids() {
        return hardGrids;
    }

    /**
     * This method will be used to either enable or disable challange mode, based on what is being passed.
     * This method will guarantee to set the challangemode flag to true or false, provided it receives a valid
     * boolean expressing the current chalange mode status.
     *
     * @param challangeMode true if challange mode should be turned on, false if it should be off
     */
    public void setChallangerMode(boolean challangeMode) {
        this.challangeMode = challangeMode;
    }

    /**
     * This method will be used for updating the border around the menu based on iff the level contains atleast one state.
     * if there is a level on the difficulty, the button for loading that level will have a slight green border, and if there
     * are no remaining levels on that difficulty, the border will be removed. this is sort of a (will i lag border).
     * This method guarantees to properly update the menu button border properties.
     */
    public void updateMenuStatus() {
        //if the easy state queue has atleast one state
        if (easyGrids.size() > 0) {
            //set a green border around the button
            menu.getChildren().get(0).setStyle("-fx-border-color: green; -fx-border-width: 2");
        } else {
            //otherwise we want to remove any border to indicate no levels
            menu.getChildren().get(0).setStyle("-fx-borer-color: none;");
        }
        //if the medium state queue has atleast one state
        if (mediumGrids.size() > 0) {
            //set a green border around the button
            menu.getChildren().get(1).setStyle("-fx-border-color: green; -fx-border-width: 2");
        } else {
            //otherwise we want to remove any border to indicate no levels
            menu.getChildren().get(1).setStyle("-fx-borer-color: none;");
        }
        //if the hard state queue has atleast one state
        if (hardGrids.size() > 0) {
            //set a green border around the button
            menu.getChildren().get(2).setStyle("-fx-border-color: green; -fx-border-width: 2");
        } else {
            //otherwise we want to remove any border to indicate no levels
            menu.getChildren().get(2).setStyle("-fx-borer-color: none;");
        }
    }

    /**
     * This method will be used to put the current thread to sleep. this will greatly reduce cpu usage and allow for the game
     * to not be a slideshow haha but no seriously its really choppy without the sleeps.
     *
     * @param time the amount of time the thread will be asleep for
     */
    public void threadSleep(long time) {
        try {
            //put the thread to sleep for the given time
            Thread.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
